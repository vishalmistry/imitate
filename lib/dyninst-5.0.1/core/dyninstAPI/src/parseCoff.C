/*
 * Copyright (c) 1996-2004 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as "Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * This license is for research uses.  For such uses, there is no
 * charge. We define "research use" to mean you may freely use it
 * inside your organization for whatever purposes you see fit. But you
 * may not re-distribute Paradyn or parts of Paradyn, in any form
 * source or binary (including derivatives), electronic or otherwise,
 * to any other organization or entity without our permission.
 * 
 * (for other uses, please contact us at paradyn@cs.wisc.edu)
 * 
 * All warranties, including without limitation, any warranty of
 * merchantability or fitness for a particular purpose, are hereby
 * excluded.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * Even if advised of the possibility of such damages, under no
 * circumstances shall we (or any other person or entity with
 * proprietary rights in the software licensed hereunder) be liable
 * to you or any third party for direct, indirect, or consequential
 * damages of any character regardless of type of action, including,
 * without limitation, loss of profits, loss of use, loss of good
 * will, or computer failure or malfunction.  You agree to indemnify
 * us (and any other person or entity with proprietary rights in the
 * software licensed hereunder) for any and all liability it may
 * incur to third parties resulting from your use of Paradyn.
 */

#include <stdio.h>
#include <filehdr.h>
#include <syms.h>
#include <cmplrs/demangle_string.h>  // For native C++ (cxx) name demangling.
#include <ctype.h>

#include "BPatch.h"
#include "BPatch_module.h"
#include "BPatch_collections.h"
#include "LineInformation.h"
#include "BPatch_typePrivate.h"
#include "BPatch_function.h"
#include "util.h"
#include "Object.h"
#include "symtab.h"
#include "mapped_object.h"
#include "mapped_module.h"
#include <ldfcn.h>  // *** GCC 3.x bug: (Short explanation)
		    // <ldfcn.h> must be included after "BPatch.h"

		    // (Long explanation): The obj.h header
		    // (which is included by ldfcn.h) has this line:
		    // "#define global".  This becomes a problem when
		    // iostream is eventually included (by BPatch.h).
		    // A variable named "global" is defined, but the
		    // keyword is erased during preprocessing.

#define NOTYPENAME ""

// Stab definitions (from gdb) 
#define CODE_MASK 0x8F300
#define ECOFF_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)
#define ECOFF_MARK_STAB(code) ((code)+CODE_MASK)
#define ECOFF_UNMARK_STAB(code) ((code)-CODE_MASK)
#define STABS_SYMBOL "@stabs"

// Main functions needed to parse stab strings.
extern pdstring current_func_name;
extern pdstring parseStabString(BPatch_module *, int linenum, char *str,
			     int fPtr, BPatch_typeCommon *commonBlock = NULL);

typedef union {
    pEXTR ext;
    pSYMR sym;
} SYMBOL, *pSYMBOL;

// eCoffParseInfo will hold the necessary state information
// as we parse an eCoff symbol table.
typedef struct {
    bool isExternal;
    pCHDRR symtab;
    pCFDR file;

    // File Descriptor Information
    char *strBase;
    SYMBOL symBase;
    pAUXU auxBase;
    pPDR pdrBase;
    pRFDT rfdBase;
    int symCount;
    int pdrCount;
} eCoffParseInfo;

// --------------------------------------------------------------------------
// Class eCoffSymbol definition. --------------------------------------------
// --------------------------------------------------------------------------
//
// eCoffSymbol will encapulate symbol data,
// abstracting away the idea of internal/external symbols.
class eCoffSymbol {
    SYMBOL sym_internal;
    eCoffParseInfo *info;

public:
    pdstring name;
    pSYMR sym;
    pAUXU aux;
    int ifd;

    eCoffSymbol(eCoffParseInfo *_info = NULL) { init(_info); }
    ~eCoffSymbol() { clear(); }

    void init(eCoffParseInfo *, bool = false);
    int index() { return (info->isExternal ? sym_internal.ext - info->symBase.ext
			  		   : sym_internal.sym - info->symBase.sym); }
    int id() { return 10000 + index() + (info->isExternal ? info->symtab->hdr.isymMax
							  : info->file->pfd->isymBase); }
    bool empty() { return sym_internal.ext == NULL; }
    eCoffParseInfo *getParseInfo() { return info; }

    void operator++();
    void operator=(int);
    void operator+=(int);

    void clear(bool = false);

private:
    void setState();
};

void eCoffSymbol::init(eCoffParseInfo *_info, bool cleanup)
{
    clear(cleanup);

    info = _info;
    if (info)
	sym_internal = info->symBase;
    else
	sym_internal.ext = NULL;

    setState();
}

void eCoffSymbol::operator++()
{
    if (info->isExternal)
	++(sym_internal.ext);
    else
	++(sym_internal.sym);

    // Bounds check.
    if (empty() || index() >= info->symCount) {
	sym_internal.ext = NULL;
	return;
    }
    setState();
}

void eCoffSymbol::operator=(int i)
{
    // Bounds check.
    if (i < 0 || i >= info->symCount) {
	sym_internal.ext = NULL;
	return;
    }

    sym_internal = info->symBase;
    if (info->isExternal)
        sym_internal.ext += i;
    else
        sym_internal.sym += i;
    setState();
}

void eCoffSymbol::operator+=(int i)
{
    if (info->isExternal)
        sym_internal.ext += i;
    else
        sym_internal.sym += i;

    // Bounds check.
    if (empty() || index() >= info->symCount) {
	sym_internal.ext = NULL;
	return;
    }
    setState();
}

void eCoffSymbol::setState()
{
    char prettyName[1024];

    if (sym_internal.ext == NULL)
	return;

    sym = info->isExternal ? &sym_internal.ext->asym : sym_internal.sym;
    ifd = info->isExternal ? sym_internal.ext->ifd : -1;

    name = (sym->iss == issNil ? "" : info->strBase + sym->iss);
    if (ECOFF_IS_STAB(sym)) {
	// Stab strings may be continued on the next symbol.
	while (name.length() > 0 && name[name.length() - 1] == '\\') {
	    if (info->isExternal)
		++(sym_internal.ext);
	    else
		++(sym_internal.sym);
	    sym = info->isExternal ? &sym_internal.ext->asym : sym_internal.sym;
	    ifd = info->isExternal ? sym_internal.ext->ifd : -1;

	    name = name.substr(0, name.length() - 1); // Remove '\\'
	    name += (sym->iss == issNil ? "" : info->strBase + sym->iss);
	}
    }

#if 0
    if (name.length() < 1024) {
	MLD_demangle_string(name.c_str(), prettyName, 1024,
			    MLD_SHOW_DEMANGLED_NAME | MLD_NO_SPACES);
	if (strchr(prettyName, '('))
	    *strchr(prettyName, '(') = 0;
	name = prettyName;
    }
#endif

    // The AUX field is a bit more tricky.  I pulled these straight
    // from the Alpha Symbol Table Specification, section 5.3.7.3.
    if (sym->st == stGlobal ||
	sym->st == stStatic ||
	sym->st == stParam ||
	sym->st == stLocal && !info->isExternal ||
	sym->st == stProc && !info->isExternal ||
	sym->st == stMember && sym->sc == scInfo ||
	sym->st == stTypedef && sym->sc == scInfo ||
	sym->st == stStaticProc && !info->isExternal ||
	sym->st == stConstant ||
	sym->st == stBase && sym->sc == scInfo ||
	sym->st == stVirtBase && sym->sc == scInfo ||
	sym->st == stTag && sym->sc == scInfo ||
	sym->st == stInter && sym->sc == scInfo ||
	sym->st == stNamespace && sym->sc == scInfo ||
	sym->st == stUsing && sym->sc == scInfo ||
	sym->st == stAlias && sym->sc == scInfo)

	aux = (sym->index != indexNil ? info->auxBase + sym->index : NULL);
    else
	aux = NULL;
}

void eCoffSymbol::clear(bool cleanup)
{
    if (cleanup && info) delete info;
    sym_internal.ext = NULL;
}
// --------------------------------------------------------------------------
// End class eCoffSymbol definition. ----------------------------------------
// --------------------------------------------------------------------------

// Function Prototypes.
bool eCoffFindModule(pCHDRR, const pdstring &, eCoffParseInfo &);
void eCoffFillInfo(pCHDRR, int, eCoffParseInfo &);
void FindLineInfo(LDFILE *, eCoffParseInfo &, pdstring, LineInformation &);
BPatch_type *eCoffParseType(BPatch_module *, eCoffSymbol &, bool = false);
BPatch_type *eCoffHandleTIR(BPatch_module *, eCoffSymbol &, bool = false);
BPatch_type *eCoffHandleTQ(eCoffSymbol &, BPatch_type *, unsigned int);
void eCoffParseProc(BPatch_module *, eCoffSymbol &, bool = false);
BPatch_type *eCoffParseStruct(BPatch_module *, eCoffSymbol &, bool = false);
void eCoffHandleRange(eCoffSymbol &, long int &, long int &, bool = false);
void eCoffHandleRange(eCoffSymbol &, pdstring &, pdstring &, bool = false);
long int eCoffHandleWidth(eCoffSymbol &, bool = false);
eCoffSymbol eCoffHandleRNDX(eCoffSymbol &, bool = false);
int eCoffGetOffset(eCoffSymbol &, pPDR);
pPDR eCoffGetFunction(eCoffSymbol &);
int stabsGetOffset(eCoffSymbol &, const char *, int);

// *** FUTURE BUG: The following code is currently designed for
// paradyn/dyninst's internal pdstring class.  While this code will still
// work if ever replaced by the STL pdstring, it could be better optimized.
// RSC (11/2002)

// fcn to construct type information
void parseCoff(BPatch_module *mod, char *exeName, const pdstring &modName,
	       LineInformation & lineInformation)
{
    LDFILE *ldptr;
    pCHDRR symtab;
    eCoffSymbol symbol;
    eCoffParseInfo currInfo;

    //
    // Initialize ldfcn structures.
    //
    ldptr = ldopen(exeName, NULL);
    if (!ldptr) {
	bperr( "Error opening %s\n", exeName);
	// Print an error message here.
        fprintf(stderr, "%s[%d]:  FIXME\n", FILE__, __LINE__);
	return;
    }

    if (LDSWAP(ldptr)) {
	// Print an error message here.
	ldaclose(ldptr);
        fprintf(stderr, "%s[%d]:  FIXME\n", FILE__, __LINE__);
	return; // Bytes are swapped
    }

    symtab = SYMTAB(ldptr);
    if (!symtab) {
	// Print an error message here.
	// bperr( "%s has no symbol table.\n", argv[1]);
	ldaclose(ldptr);
        fprintf(stderr, "%s[%d]:  FIXME\n", FILE__, __LINE__);
	return;
    }

    if (!eCoffFindModule(symtab, modName, currInfo)) {
	// Print an error message here.
        fprintf(stderr, "%s[%d]:  Can't find module %s\n", FILE__, __LINE__, modName.c_str());
	return;
    }

    if (!currInfo.isExternal)
	FindLineInfo(ldptr, currInfo, modName, lineInformation);

    // STAB parse preparation.
    current_func_name = NULL;
    bool stabFormat = false;

    //
    // Main parsing loop.
    //
    for (symbol.init(&currInfo); !symbol.empty(); ++symbol) {

	//
	// STABS encoded within eCoff.
	//
	if (stabFormat && ECOFF_IS_STAB(symbol.sym)) {
	    int typeCode = ECOFF_UNMARK_STAB(symbol.sym->index);
	    if (typeCode == 138)
		typeCode = 128; //Why?
	    else if (typeCode == 42)
		typeCode = 32; //Why?
	    else if (typeCode == 46)
		typeCode = 36; //Why?
	    else if (typeCode == 170)
		typeCode = 160; //Why?

	    switch (typeCode) {
	    case 0x64:  // N_SO
	    case 0x84:  // N_SOL
		current_func_name = NULL; // reset for next object file
		continue;

	    case 32:    // Global symbols -- N_GSYM
	    case 36:    // functions and text segments -- N_FUN
	    case 128:   // typedefs and variables -- N_LSYM
	    case 160:   // parameter variable -- N_PSYM
		int value = symbol.sym->value;
		if ( ((typeCode == 128) || (typeCode == 160)) && current_func_name.length() ) {
		    // See note above about STL strings.  This section of code
		    // applies in particular.
		    int varType = stLocal;
		    char *p = strchr(symbol.name.c_str(), ':');

		    if (!p)
			continue; // Not stab format!
		    p++;
		    if (*p == 'p') varType = stParam;

		    value = stabsGetOffset(symbol, current_func_name.c_str(), varType);
		}

		pdstring temp = parseStabString(mod, 0, const_cast<char *>(symbol.name.c_str()),
                                             value);
		if (temp != "") {
		    // Error parsing the stabstr, return should be \0
		    bperr("Stab string parsing ERROR!! More to parse: %s\n", temp.c_str());
		}
		break;
	    }
	    continue;
	}

	else if (stabFormat || ECOFF_IS_STAB(symbol.sym)) {
	    if (symbol.name == STABS_SYMBOL)
		stabFormat = true;
	    continue;
	}

	//
	// Pure eCoff.
	//
	else {
	    switch(symbol.sym->st) {

	    case stProc:  // Function definitions
	    case stStaticProc:
		eCoffParseProc(mod, symbol);
		break;

	    case stGlobal:
	    case stConstant:
	    case stStatic:
		if (_SC_IS_DATA(symbol.sym->sc) || _SC_IS_TLSDATA(symbol.sym->sc)) {
		    BPatch_type *ptrType = eCoffParseType(mod, symbol);
		    if (ptrType) {
			mod->getModuleTypes()->addGlobalVariable(symbol.name.c_str(), ptrType);
                    }
                    else {
#if 0
                       fprintf(stderr, "%s[%d]:  no type for symbol %s\n", FILE__, __LINE__, symbol.name.c_str());
#endif

                    }
		}
		break;

	    case stTypedef: // Simple typedef.
	    case stBlock:   // Possible C structure, union, or enum.
	    case stBase:    // Base class.
	    case stTag:     // C++ class, structure, union, or enum.
		if (!eCoffParseType(mod, symbol, true)) {
                  fprintf(stderr, "%s[%d]:  no type for %s\n", FILE__, __LINE__, symbol.name.c_str());
                }
		break;

	    case stFile:
		// Module file name information.  We already have the
		// information contained in this symbol.  Ignore it.

	    case stLocal:
	    case stParam:
		// These two should never happen outside of an stProc
		// or stStaticProc block.  Should we print an error?

	    default:
		break;
	    } //switch
	}
    }

    //Close the file
    ldaclose(ldptr);
}

bool eCoffFindModule(pCHDRR symtab, const pdstring &modName, eCoffParseInfo &info)
{
    if (modName == "DEFAULT_MODULE") {
	// As far as I can tell, the external symbols hold the
	// information requested by DEFAULT_MODULE.
	eCoffFillInfo(symtab, -1, info);
	return true;

    } else {
	pCFDR file = symtab->pcfd;
	for (int i = 0; i < symtab->cfd; ++i) {
	    char *name = file[i].pss + file[i].pfd->rss;

	    // Ignore anonymous modules.
	    if (file[i].pfd->rss == issNil)
		continue;

	    // Ignore full pathname.  (Should we be doing this?)
	    if (strrchr(name, '/') != NULL)
		name = strrchr(name, '/') + 1;

	    // Check to see if we've found the desired module.
	    if (modName == name) {
		eCoffFillInfo(symtab, i, info);
		return true;
	    }
	}
    }
    return false;
}

void eCoffFillInfo(pCHDRR symtab, int fileIndex, eCoffParseInfo &info)
{
    // Sanity Check
    assert(fileIndex != -1 || symtab != NULL);

    info.symtab = symtab;
    if (fileIndex == -1) {
	// Retrieve external symbol information

	info.isExternal = true;
	info.file = NULL;
	info.strBase = symtab->pssext;
	info.symBase.ext = symtab->pext;
	info.auxBase = symtab->paux;
	info.pdrBase = symtab->ppd;
	info.rfdBase = NULL; // This will be filled out later.

	info.symCount = symtab->cext;
	info.pdrCount = symtab->hdr.ipdMax;

    } else {
	pCFDR file = symtab->pcfd + fileIndex;

	info.isExternal = false;
	info.file = file;
	info.strBase = file->pss;
	info.symBase.sym = file->psym;
	info.auxBase = file->paux;
	info.pdrBase = file->ppd;
	info.rfdBase = file->prfd;

	info.symCount = file->pfd->csym;
	info.pdrCount = file->pfd->cpd;
    }
}

void FindLineInfo(LDFILE *ldptr, eCoffParseInfo &info,
                  pdstring fileName, LineInformation& lineInformation)
{
    // For some reason, the count fields of pCFDR structures are not
    // filled out correctly when the symbol table is read in via the
    // SYMTAB() macro (or any other way).  We must use the underlying
    // FDR structure instead.
    char funcName[1024];
    pCFDR fileDesc = info.file;
    pSYMR tempSym;

    //
    // Manually read in line information due to buggy LDFCN library.
    //
    unsigned char *lineInfo = (unsigned char *)malloc(info.symtab->hdr.cbLine);
    if (!lineInfo) {
		bperr( "*** WARNING: Cannot read line information ");
		bperr( "for file %s: Malloc error.\n", fileName.c_str());
		return;
    	}
    int numleft = info.symtab->hdr.cbLine;
    FSEEK(ldptr, info.symtab->hdr.cbLineOffset, 0);
    while (numleft > 0) numleft -= FREADM(lineInfo, 1, numleft, ldptr);

    // for each procedure entry look at the information
    for (int i = 0; i < fileDesc->pfd->cpd; i++) {
        pPDR procedureDesc = fileDesc->ppd + i;

        // No name is available for proc.
        if (!fileDesc->psym || !fileDesc->pfd->csym || procedureDesc->isym == -1) continue;

        // Get the (demangled) name of the procedure, if available.
        tempSym = fileDesc->psym + procedureDesc->isym;	
        MLD_demangle_string(fileDesc->pss + tempSym->iss, funcName, 1024, 
                            MLD_SHOW_DEMANGLED_NAME | MLD_NO_SPACES);
		if (P_strchr(funcName, '(')) *P_strchr(funcName, '(') = 0;

		if (P_strlen(funcName) == 0)
		    continue;

//      lineInformation->insertSourceFileName( pdstring(funcName), fileName.c_str(),
//            &currentFileInfo,&currentFuncInfo);

        // no line information for the filedesc is available
        if (!fileDesc->pfd->cline || !fileDesc->pline || procedureDesc->iline == -1) continue;

		// (Possibly buggy) GCC line information check.
		if (procedureDesc->lnLow == 6 && procedureDesc->lnHigh == 6) {
		    //
		    // GCC eCoff Line Information
		    //
		    tempSym = (fileDesc->psym + procedureDesc->isym + 1);

			bool isPreviousValid = false;
			unsigned int prevLineNo = 0;
			unsigned long prevLineAddr = 0; 
			
		    while (tempSym->st == stLabel && tempSym->sc == scText) {
//				currentFileInfo->insertLineAddress(currentFuncInfo,
//							   tempSym->index,
//							   tempSym->value);
//				/* DEBUG */ fprintf( stderr, "%s[%d]: %s:%d @ 0x%lx\n", __FILE__, __LINE__, fileName.c_str(), tempSym->index, tempSym->value );

				/* FIXME: the source file information is wildly wrong.  Someone
				   who understands ECOFF should fix this.  (One possibility is
				   to use the name of the module the function is in.) */
				if( isPreviousValid ) {
					lineInformation.addLine( fileName.c_str(), prevLineNo, prevLineAddr, tempSym->value );
					}
				else {
					isPreviousValid = true;
					}
				prevLineNo = tempSym->index;
				prevLineAddr = tempSym->value;

				++tempSym;
	    		}
	    	if( isPreviousValid ) {
	    		/* FIXME: add the range from prevLineAddr to the end of the function.
	    		   We should either use the beginning of the next entry in the symbol table,
	    		   or the size of the basic block which prevLineAddr should probably start. 
	    		   
	    		   Since I don't know how to get function addresses out of ECOFF, however,
	    		   this'll have to wait. */

                   if (tempSym->st == stEnd && tempSym->sc == scText) {
                      lineInformation.addLine( fileName.c_str(), prevLineNo, prevLineAddr, procedureDesc->adr + tempSym->value );
                   }

	    		}

			} else {
		    //
		    // Pure eCoff Line Information
	    	//
		    int idx = fileDesc->pfd->cbLineOffset + procedureDesc->cbLineOffset;
		    int endidx;
		    int currLine = procedureDesc->lnLow;
	    	unsigned long currAddr = procedureDesc->adr;

		    // Find end index
		    int nextpd = -1;
	    	for (int pcount = 0; pcount < fileDesc->pfd->cpd; ++pcount) {
				pPDR pd = fileDesc->ppd + pcount;
				if (pd != procedureDesc && pd->iline != ilineNil && pd->cbLineOffset >= procedureDesc->cbLineOffset)
				    if (nextpd == -1 || pd->cbLineOffset < fileDesc->ppd[nextpd].cbLineOffset)
						nextpd = pcount;
	    		}
		    endidx = (nextpd == -1 ? fileDesc->pfd->cbLine
					   : fileDesc->ppd[nextpd].cbLineOffset);
		    endidx -= procedureDesc->cbLineOffset;
		    endidx += idx;

			bool isPreviousValid = false;
			unsigned int prevLineNo = 0;
			unsigned long prevLineAddr = 0;

		    while (idx < endidx) {
				long delta;

//				currentFileInfo->insertLineAddress(currentFuncInfo,
//							   currLine, currAddr);
				/* DEBUG  fprintf( stderr, "%s[%d]: %s:%d @ 0x%lx\n", __FILE__, __LINE__, fileName.c_str(), currLine, currAddr ); */

				/* See comments in the gcc case, above. */
				if( isPreviousValid ) {
					lineInformation.addLine( fileName.c_str(), prevLineNo, prevLineAddr, currAddr );
					}
				else { 
					isPreviousValid = true;
					}
				prevLineNo = currLine;
				prevLineAddr = currAddr;

				currAddr += ((lineInfo[idx] & 0xFU) + 1) * 4;
				if ((lineInfo[idx] & 0xF0U) == 0x80U) {
				    // Extended Delta
				    ++idx;
				    delta = ((signed char)lineInfo[idx]) << 8;
				    ++idx;
				    delta |= lineInfo[idx];
					} else
				    delta = ((signed char)lineInfo[idx]) >> 4;

				currLine += delta;
				++idx;
	    	}
        }
    }
    free(lineInfo);
}

BPatch_type *eCoffParseType(BPatch_module *mod, eCoffSymbol &symbol, bool typeDef) 
{
    int id = symbol.id();
    pdstring name;
    eCoffSymbol remoteSymbol;
    BPatch_type *newType = NULL;

    // Symbol has no type information.
    if (!symbol.aux && symbol.sym->st != stBlock) {
#if 0
        fprintf(stderr, "%s[%d]:  symbol %s has no type\n", FILE__, __LINE__, symbol.name.c_str());
        fprintf(stderr, "%s[%d]:  symbol.aux = %d\n", FILE__, __LINE__, symbol.aux);
        fprintf(stderr, "%s[%d]:  symbol.sym->st = %d, stBlock = %d\n", FILE__, __LINE__, symbol.sym->st, stBlock);
#endif
	return NULL;
    }

    newType = mod->getModuleTypes()->findType(id);
    if (newType) {
	// This type is already inserted.

	if (symbol.sym->st == stTag ||
	    symbol.sym->st == stBase ||
	    symbol.sym->st == stBlock) {

	    // Skip to end of block definition.
	    eCoffParseStruct(mod, symbol, true);
	}
	return newType;
    }

    switch (symbol.sym->st) {

    case stTag:    // C++ class, structure, union, or enum.
    case stBase:   // C++ base class.
    case stBlock:  // Possible C structure, union, or enum.
	newType = eCoffParseStruct(mod, symbol);
	break;

    case stInter:
	eCoffHandleRNDX(symbol);
	// Fall through (don't break).

    case stUsing:
	eCoffHandleRNDX(symbol);
        fprintf(stderr, "%s[%d]:  symbol %s has no type\n", FILE__, __LINE__, symbol.name.c_str());
	return NULL;

    case stAlias:
	remoteSymbol = eCoffHandleRNDX(symbol);
	newType = eCoffParseType(mod, remoteSymbol);
	remoteSymbol.clear(true);
	break;

    case stTypedef:
	name = symbol.name;
	newType = eCoffHandleTIR(mod, symbol, true);

	if (newType)
	    newType = new BPatch_typeTypedef(id, newType, name.c_str());
	break;

    default:
	newType = eCoffHandleTIR(mod, symbol);
	break;
    }

    if (typeDef && newType)
	mod->getModuleTypes()->addType(newType);

    if (!newType) {
	bperr( "*** Error processing symbol %s\n", symbol.name.c_str());
    }

    return newType;
}

BPatch_type *eCoffHandleTIR(BPatch_module *mod, eCoffSymbol &symbol, bool /*typeDef*/)
{
    pdstring low, high, name;
    long int width = -1;
    eCoffSymbol remoteSymbol;
    pAUXU currTIR = (symbol.aux)++;
    BPatch_type *result, *subType;

    // Handle explicit width field (bitfields)
    if (currTIR->ti.fBitfield) {
	width = eCoffHandleWidth(symbol, false);
    }

    result = NULL;

    switch(currTIR->ti.bt) {

    case btEnum:
    case btClass:
    case btStruct:
    case btUnion:
	remoteSymbol = eCoffHandleRNDX(symbol);
#if 0
        if (currTIR->ti.bt == btStruct)
          fprintf(stderr, "%s[%d]:  bt struct %s local, %s remote\n", FILE__, __LINE__, symbol.name.c_str(), remoteSymbol.name.c_str());
#endif
	result = eCoffParseType(mod, remoteSymbol, true);
	remoteSymbol.clear(true);
	break;

    case btRange:
    case btRange_64:
	remoteSymbol = eCoffHandleRNDX(symbol);
	subType = eCoffParseType(mod, remoteSymbol);
	remoteSymbol.clear(true);

	eCoffHandleRange(symbol, low, high, currTIR->ti.bt == btRange_64);
        result = new BPatch_typeRange(symbol.id(), subType->getSize(), low.c_str(), high.c_str(), symbol.name.c_str());
	break;

    case btTypedef:
	name = symbol.name;
	remoteSymbol = eCoffHandleRNDX(symbol);
	subType = eCoffParseType(mod, remoteSymbol);
	remoteSymbol.clear(true);

	if (subType)
	    result = new BPatch_typeTypedef(symbol.id(), subType, name.c_str());
	break;

    case btIndirect:
	// Rndx points to an entry in the aux symbol table that contains a TIR
	remoteSymbol = eCoffHandleRNDX(symbol, true);
	result = eCoffHandleTIR(mod, remoteSymbol);
	remoteSymbol.clear(true);

	// All done.  No need to parse TIR records.
	return result;

    case btProc:
	remoteSymbol = eCoffHandleRNDX(symbol);
        remoteSymbol.aux++; // Skip over isym
        result = new BPatch_typeFunction(symbol.id(), 
                                         eCoffHandleTIR(mod, remoteSymbol, true),
                                         symbol.name.c_str());
	break;

    case btSet:
    case btAdr32:
    case btComplex:
    case btDComplex:
    case btFixedDec:
    case btFloatDec:
    case btString:
    case btBit:
    case btPicture:
    case btPtrMem:
    case btVptr:
    case btAdr64:
    case btChecksum:
 // case btAdr: Same as btAdr64
 // case btArrayDesc: FORTRAN 90: Array descriptor
 // case btScaledBin: COBOL: Scaled Binary
 // case btDecimal: COBOL: packed/unpacked decimal
 // case btFixedBin: COBOL: Fixed binary
	// Nothing to do!
	result = NULL;
	break;

    case btNil: // Regarded as void
    case btVoid:
       result = mod->getModuleTypes()->findType("void");
	break;

    case btChar:
       result = mod->getModuleTypes()->findType("char");
	break;

    case btUChar:
       result = mod->getModuleTypes()->findType("unsigned char");
	break;

    case btShort:
       result = mod->getModuleTypes()->findType("short");
	break;

    case btUShort:
       result = mod->getModuleTypes()->findType("unsigned short");
	break;

    case btInt32:
       result = mod->getModuleTypes()->findType("int");
	break;

    case btUInt32:
       result = mod->getModuleTypes()->findType("unsigned int");
	break;

    case btLong32:
       // Treat 32-bit longs as ints
       result = mod->getModuleTypes()->findType("int");
	break;

    case btULong32:
       result = mod->getModuleTypes()->findType("unsigned int");
	break;

    case btFloat:
       result = mod->getModuleTypes()->findType("float");
	break;

    case btDouble:
       result = mod->getModuleTypes()->findType("double");
	break;

    case btLong64:
 // case btLong: Same as btLong64
    case btLongLong64:
 // case btLongLong: Same as btLongLong64
    case btInt64:
       result = mod->getModuleTypes()->findType("long long");
	break;

    case btULong64:
 // case btULong: Same as btULong64
    case btULongLong64:
 // case btULongLong: Same as btULongLong64
    case btUInt64:
       result = mod->getModuleTypes()->findType("unsigned long long");
	break;

    case btLDouble:
       result = mod->getModuleTypes()->findType("long double");
	break;

    case btInt8:
    case btUInt8:
       result = mod->getModuleTypes()->findType("integer*1");
	break;

    default:
	// Never to reach here!
	result = NULL;
	break;
    } // switch

    if (!result)
	return NULL; // Something wrong!

    // Handle type qualifiers
    while (currTIR) {
	unsigned int tq;
  	for (int tcount = 0; tcount < itqMax; ++tcount) {
	    switch (tcount) {
		case 0: tq = currTIR->ti.tq0; break;
		case 1: tq = currTIR->ti.tq1; break;
		case 2: tq = currTIR->ti.tq2; break;
		case 3: tq = currTIR->ti.tq3; break;
		case 4: tq = currTIR->ti.tq4; break;
		case 5: tq = currTIR->ti.tq5; break;
	    }
	    if (tq != tqNil)
		result = eCoffHandleTQ(symbol, result, tq);
	    else
		break;
	}
	currTIR = (currTIR->ti.continued ? ++(symbol.aux) : NULL);
    }
    return result;
}

BPatch_type *eCoffHandleTQ(eCoffSymbol &symbol, BPatch_type *prevType, unsigned int tq)
{
    long int low, high;
    BPatch_type *newType = NULL;
    eCoffSymbol indexType;

    assert(prevType);

    switch (tq) {
    case tqProc:
       newType = new BPatch_typeFunction(symbol.id(), prevType, symbol.name.c_str());
	break;

    case tqRef:
       newType = new BPatch_typeRef(symbol.id(), prevType, symbol.name.c_str());
	break;

    case tqPtr:
    case tqFar: // Ptr type qualifier
       newType = new BPatch_typePointer(symbol.id(), prevType, symbol.name.c_str());
	break;

    case tqArray:
    case tqArray_64: // Array handling
	// Parse (but ignore) rndx to array subscript.
	indexType = eCoffHandleRNDX(symbol);
	indexType.clear(true); // Memory clean up

	// Parse range.
	eCoffHandleRange(symbol, low, high, tq == tqArray_64);

	// Parse (but ignore) width.
	eCoffHandleWidth(symbol, tq == tqArray_64);

        newType = new BPatch_typeArray(symbol.id(), prevType, low, high, symbol.name.c_str());
	break;

    case tqVol:		// Volitile
    case tqConst:	// Constant
    case tqShar:	// Shareable UPC
    case tqSharArr_64:	// Array_64 distributed across processors UPC
	// Don't know what to do with these, but they are
	// valid.  Return the original BPatch_type unmodified.
	newType = prevType;
	break;

    case tqNil: // End of record.  Return NULL.
	break;
    }
    return newType;
}

void eCoffParseProc(BPatch_module *mod, eCoffSymbol &symbol, bool skip)
{
    int endIndex;
    BPatch_type *typePtr;
    BPatch_localVar *local;

    BPatch_Vector<BPatch_function *> bpfv;
    BPatch_function *fp = NULL;

       // get the base address of the procedure
    pdstring sname = symbol.name;
    const char *fname = sname.c_str();
    if (!fname) return;  // Some findFunction in this file is passing in NULL

    mod->findFunction(fname, bpfv, false /* no print */);
    if (!bpfv.size()) {
      //cerr << __FILE__ << __LINE__ << ":  Unable to find function: " << symbol.name << endl;
      return;
    }
    fp = bpfv[0];
    if (!fp) return;

    // Sanity check.
    if (!fp || symbol.sym->st != stProc && symbol.sym->st != stStaticProc)
	return;

    // Handle external pointers into local tables.
    if (symbol.getParseInfo()->isExternal) {
	eCoffParseInfo localInfo, *info = symbol.getParseInfo();
	eCoffSymbol localSymbol;

	eCoffFillInfo(info->symtab, symbol.ifd, localInfo);
	localSymbol.init(&localInfo);
	localSymbol += symbol.sym->index;
	eCoffParseProc(mod, localSymbol);

	return;
    }

    // Skip to end if requested, or if we've already seen this function.
    endIndex = symbol.aux->isym - 1;
    ++(symbol.aux);
    if (skip || fp->getReturnType()) {
	symbol = endIndex;
	return;
    }

    // Set return type.
    typePtr = eCoffParseType(mod, symbol);
    if (typePtr) fp->setReturnType(typePtr);

    if (symbol.sym->sc == scInfo) {
	switch (symbol.sym->value) {
	case -1: // Procedure with no code.
	    // Skip to end for now.
	    // I don't know what to do with it.
	    symbol = endIndex;
	    break;

	case -2: // Function prototype or function pointer definition.
	    
	    break;

	default: // C++ virtual member function.
	    break;
	}

    } else if (symbol.sym->sc == scText) {
	//
	// Function definition.
	//
	pPDR currFunc = eCoffGetFunction(symbol);

	++symbol;
	while (symbol.index() < endIndex) {
	    bool isOffset = (symbol.sym->sc == scAbs || symbol.sym->sc == scVar);
	    int value = (isOffset ? eCoffGetOffset(symbol, currFunc) : symbol.sym->value);

	    switch (symbol.sym->st) {
	    case stParam:
		if (symbol.sym->sc == scAbs ||
		    symbol.sym->sc == scRegister ||
		    symbol.sym->sc == scVar ||
		    symbol.sym->sc == scVarRegister ||
		    symbol.sym->sc == scUnallocated ||
		    _SC_IS_DATA(symbol.sym->sc) ) {

		    typePtr = eCoffParseType(mod, symbol);
		    local = new BPatch_localVar(symbol.name.c_str(), typePtr, -1, value, 0,
						( isOffset ? BPatch_storageFrameOffset
							   : BPatch_storageAddr ) );
		    fp->funcParameters->addLocalVar(local);
		    fp->addParam(symbol.name.c_str(), typePtr, -1, value, 0,
				 ( isOffset ? BPatch_storageFrameOffset
				   : BPatch_storageAddr ) );
		}
		break;

	    case stLocal:
		if (symbol.sym->sc == scAbs ||
		    symbol.sym->sc == scRegister ||
		    symbol.sym->sc == scVar ||
		    symbol.sym->sc == scVarRegister ||
		    symbol.sym->sc == scUnallocated) {

		    // Unfortunatly, eCoff has no notion of line numbers for
		    // local variable definitions.
		    typePtr = eCoffParseType(mod, symbol);
		    local = new BPatch_localVar(symbol.name.c_str(), typePtr, -1, value, 0,
						( isOffset ? BPatch_storageFrameOffset
							   : BPatch_storageAddr ) );
		    fp->localVariables->addLocalVar(local);
		}
		break;

	    case stStatic:
		if (symbol.sym->sc == scCommon) {
		    typePtr = eCoffParseType(mod, symbol);

		    if (typePtr) {
			// Bad hack.  Fortran common blocks have both a module, and a
			// global variable defined in the symbol table using the same
			// name.  Since AObject::symbols_ was modified to be a
			// dictionary_hash< pdstring, pdvector< Symbol > >, the symbol
			// is no longer correctly found by BPatch_image::findVariable.
			// 
			// So, we use the following manual search instead.
			Object &img =
			  const_cast<Object &>(mod->lowlevel_mod()->pmod()->exec()->getObject());
			pdvector< Symbol > symbols;
			img.get_symbols( symbol.name, symbols );

			long baseAddr = 0;
			for (unsigned int i = 0; i < symbols.size(); ++i) {
			    if (symbols[i].type() == Symbol::PDST_OBJECT) {
				baseAddr = symbols[i].addr();
				break;
			    }
			}

			BPatch_Vector<BPatch_field *> *fields = typePtr->getComponents();
			for (unsigned int i = 0; i < fields->size(); ++i) {
			    int offset = (*fields)[i]->getOffset() / 8;
			    local = new BPatch_localVar((*fields)[i]->getName(),
							(*fields)[i]->getType(),
							-1,
							baseAddr + offset,
							0,
							BPatch_storageAddr);
			    fp->localVariables->addLocalVar(local);
			}
		    }
		}

	    case stProc:
	    case stStaticProc:
		if (symbol.aux->isym == indexNil) {
		    // Fortran alternate entry point.
		    ++symbol;
		    while (symbol.sym->st == stParam) {
			++symbol;
		    }
		} else {
		    // Nested function.
		    eCoffParseProc(mod, symbol);
		}
		break;
	    }
	    ++symbol;
	}
    }
}

// Parses the symbols associated with user-defined types.
// Eg: Classes, structures, unions, and enumerations.
template class pdvector<BPatch_type *>;
BPatch_type *eCoffParseStruct(BPatch_module *mod, eCoffSymbol &symbol, bool skip)
{
   static BPatch_module *mod_cache = NULL;
   static pdvector<BPatch_type *> local_type_cache;

   int endIndex;
   BPatch_type *result, *field;
   BPatch_dataClass dataType = BPatch_unknownType;
   bool isKnown = false, isEnum = false, isStruct = false;

   // Sanity checks.
   if (! ((symbol.sym->st == stTag) ||
          (symbol.sym->st == stBlock && (symbol.sym->sc == scInfo ||
                                         symbol.sym->sc == scCommon ||
                                         symbol.sym->sc == scSCommon))))
      return NULL;

   // Block already parsed.  Skip to end.
   if (skip) {
      if (symbol.sym->st == stTag) ++symbol;
      symbol = symbol.sym->index - 1;
      return NULL;
   }

   //  Local type cache should only be valid within the same BPatch_module.
   //  If the BPatch_module changes, we should invalidate the cache.
   if (mod_cache != mod) {  // Works for initial and change conditions.
       local_type_cache.clear();
       mod_cache = mod;
   }

   //  check our local type cache for a type of this name/id
   //  if we have one that matches, return it (this is a recursion guard)
   for (unsigned int i = 0; i < local_type_cache.size(); ++i) {
      if (symbol.id() == local_type_cache[i]->getID()) {
#if 0
         fprintf(stderr, "%s[%d]:  RECURSION GUARD HIT FOR TYPE %s\n", FILE__, __LINE__, symbol.name.c_str());
#endif
         return local_type_cache[i];
      }
   }

   // Determine data class.
   if (symbol.sym->st == stTag) {

      // C++ structure, union, or enumeration.
      switch (symbol.aux->ti.bt) {
        case btStruct:
           dataType = BPatch_structure;
           result = new BPatch_typeStruct(symbol.id(), symbol.name.c_str());
           break;
        case btUnion:
           dataType = BPatch_union;
           result = new BPatch_typeUnion(symbol.id(), symbol.name.c_str());
           break;
        case btEnum:
           dataType = BPatch_enumerated;
           result = new BPatch_typeEnum(symbol.id(), symbol.name.c_str());
           break;
        case btClass:
           dataType = BPatch_typeClass;
           // For now
           result = new BPatch_typeStruct(symbol.id(), symbol.name.c_str());
           break;
      }
      if (dataType != BPatch_unknownType)
         isKnown = true;

      ++symbol;

   } else if (symbol.sym->sc == scCommon ||
              symbol.sym->sc == scSCommon) {

      // Fortran common block.
      dataType = BPatch_dataCommon;
      result = new BPatch_typeCommon(symbol.id(), symbol.name.c_str());      
      isKnown = true;

   } else {

#if 0
      fprintf(stderr, "%s[%d]:  C-style thingy: st = %d, sc = %d, name = %s\n", 
              FILE__, __LINE__, symbol.sym->st, symbol.sym->sc, symbol.name.c_str());
#endif
      // C style structure, union, or enumeration.
      // Assume enumeration for now.
      dataType = BPatch_enumerated;
   }

   /*
   result = new BPatch_type(symbol.name.c_str(), symbol.id(),
                            dataType, symbol.sym->value);
   */

   // Horrid hack to recreate type later.  I hate you ECOFF

   if (!isKnown) {
      result = new BPatch_typeStruct(symbol.id(), symbol.name.c_str());           
      isEnum = true;
      isStruct = false;
   }

   //  add our newly created type to the recursion guard so that if we 
   //  hit a recurring instance of it in the member list, 
   //  we will not regard it as a new type
   if (result)
      local_type_cache.push_back(result);

   endIndex = symbol.sym->index - 1;
   while (symbol.index() < endIndex) {
      pdstring fieldName = symbol.name;
      long fieldOffset = symbol.sym->value;

      // Terrible capitalization hack (Fortran only).
      if (dataType == BPatch_dataCommon) {
         fieldName = "";
         for (unsigned int i = 0; i < symbol.name.length(); ++i)
            fieldName += pdstring((char)tolower(symbol.name[i]));
         symbol.name = fieldName;
      }

      if (symbol.sym->st == stMember) {

         field = eCoffHandleTIR(mod, symbol);
         if (field) {
            // Adding a struct/union member
            dynamic_cast<BPatch_fieldListType*>(result)->addField(fieldName.c_str(), field->getDataClass(), field,
                             fieldOffset, field->getSize(), BPatch_visUnknown);
            if (fieldOffset > 0) isStruct = true;
            isEnum = false;

         } else
            // Adding an enum member
            dynamic_cast<BPatch_fieldListType*>(result)->addField(fieldName.c_str(), BPatch_scalar, symbol.sym->value,
                             BPatch_visUnknown);
      }
      if (symbol.sym->st == stProc && symbol.sym->sc == scInfo)
         eCoffParseProc(mod, symbol, true);

      ++symbol;
   }

   if (!isKnown && !isStruct) {
      BPatch_fieldListType *tempType;
      if (isEnum)
         tempType = new BPatch_typeEnum(symbol.id(), symbol.name.c_str());
      else
         tempType = new BPatch_typeUnion(symbol.id(), symbol.name.c_str());

      BPatch_Vector<BPatch_field *> *fields = dynamic_cast<BPatch_fieldListType*>(result)->getComponents();
      for (unsigned int i = 0; i < fields->size(); i++) {
         BPatch_field *bpfield = (*fields)[i];
         if (isEnum)
            tempType->addField(bpfield->getName(), BPatch_scalar, bpfield->getValue(),
                               BPatch_visUnknown);
         else
            tempType->addField(bpfield->getName(), bpfield->getTypeDesc(), 
                               bpfield->getType(), bpfield->getOffset(), 
                               bpfield->getSize(), BPatch_visUnknown);
      }
      result->decrRefCount();
      result = tempType;
   }

   //  remove result from recursion guard, if it is represented there
   for (int i = local_type_cache.size() -1; i >= 0; i--) {
     if (local_type_cache[i] == result)
        local_type_cache.erase(i,i); 
   }

   return result;
}

void eCoffHandleRange(eCoffSymbol &symbol, long int &low, long int &high, bool range_64)
{
    low = symbol.aux->dnLow;
    ++(symbol.aux);
    if (range_64) {
       // Low range consists of 2 records.
       low |= ((long int)symbol.aux->dnLow) << 32;
       ++(symbol.aux);
    }

    high = symbol.aux->dnHigh;
    ++(symbol.aux);
    if (range_64) {
       // High range consists of 2 records.
       high |= ((long int)symbol.aux->dnHigh) << 32;
       ++(symbol.aux);
    }
}

void eCoffHandleRange(eCoffSymbol &symbol, pdstring &s_low, pdstring &s_high,
                      bool range_64)
{
    long int i_low, i_high;
    char tmp[100]; // The largest 64 bit integer requires 21 bytes to store
		   // as a string.  Buffer overflow should not be a problem.

    eCoffHandleRange(symbol, i_low, i_high, range_64);

    snprintf(tmp, sizeof(tmp), "%ld", i_low);
    s_low = tmp;

    snprintf(tmp, sizeof(tmp), "%ld", i_high);
    s_high = tmp;
}

long int eCoffHandleWidth(eCoffSymbol &symbol, bool width_64)
{
    long int result;

    result = symbol.aux->width;
    ++(symbol.aux);
    if (width_64) {
       result |= ((long int)symbol.aux->width) << 32;
       ++(symbol.aux);
    }
    return result;
}

eCoffSymbol eCoffHandleRNDX(eCoffSymbol &symbol, bool isAux)
{
   pCFDR remoteFile;
   int fileIdx = symbol.aux->rndx.rfd;
   int symIdx = symbol.aux->rndx.index;
   eCoffParseInfo *info = symbol.getParseInfo(), *remoteInfo = new eCoffParseInfo;
   
   ++(symbol.aux);
   if (fileIdx == ST_RFDESCAPE) {
      fileIdx = symbol.aux->isym;
      ++(symbol.aux);
   }
   
   if (symbol.ifd == -1)
      // Local symbol, use current file.
      remoteFile = info->file;
   else
      // External symbol pointing into local table.
      remoteFile = info->symtab->pcfd + symbol.ifd;
   
   if (remoteFile->prfd)
      fileIdx = remoteFile->prfd[fileIdx];
   eCoffFillInfo(info->symtab, fileIdx, *remoteInfo);
   
   eCoffSymbol result(remoteInfo);
   if (isAux) {
      result.name = symbol.name;
      result.sym = symbol.sym;
      result.aux += symIdx;
   } else
      result = symIdx;
   
   return result;
}

// eCoffGetFunction() returns the pPDR structure associated
// with a stProc or stStaticProc.
pPDR eCoffGetFunction(eCoffSymbol &symbol) {
    eCoffParseInfo *info = symbol.getParseInfo();

    for (int i = 0; i < info->pdrCount; ++i)
       if (info->pdrBase[i].isym == symbol.index())
          return info->pdrBase + i;

    return NULL;
}

// Straight from the documentation:
// Alpha Symbol Table Specification, Section 5.3.4.3
int eCoffGetOffset(eCoffSymbol &symbol, pPDR func) {
    if (!func) return -1;
    if (symbol.sym->st == stLocal)
       return (func->frameoffset - func->localoff + symbol.sym->value);
    else
       return (func->frameoffset - 48 + symbol.sym->value);
}

// This version returns the pPDR structure associated
// with a text string.  Very inefficient.
pPDR stabsGetFunction(eCoffSymbol &origSymbol, const char *func) 
{
    eCoffParseInfo *info = origSymbol.getParseInfo();
    assert(info);
    eCoffSymbol symbol(info);

    pPDR ret = NULL;
    for (int i = 0; i < info->pdrCount; ++i) {
       symbol = info->pdrBase[i].isym;
       if (symbol.name == func) {
          ret = info->pdrBase + i;
          break;
       }
    }
    return ret;
}

int stabsGetOffset(eCoffSymbol &symbol, const char *func, int st) 
{
    if (!func) return -1;
    pPDR func_pdr = stabsGetFunction(symbol, func);

    if (!func_pdr) {
       extern pdstring current_mangled_func_name;
       func_pdr = stabsGetFunction(symbol, current_mangled_func_name.c_str());
       if (!func_pdr) {
         fprintf(stderr, "%s[%d]:  stabsGetFunction failed for %s/%s\n", FILE__, __LINE__, symbol.name.c_str(), func);
         return -1;
       }

    }
    assert(func_pdr);
    assert(symbol.sym);

    if (st == stLocal)
       return (func_pdr->frameoffset - func_pdr->localoff + symbol.sym->value);
    else
       return (func_pdr->frameoffset - 48 + symbol.sym->value);
}
